"""
言語処理100本ノック 第3章課題

41. 係り受け解析結果の読み込み（文節・係り受け）
40に加えて，文節を表すクラスChunkを実装せよ．このクラスは形態素（Morphオブジェクト）のリスト（morphs），係り先文節インデックス番号（dst），係り元文節インデックス番号のリスト（srcs）をメンバ変数に持つこととする．さらに，入力テキストの係り受け解析結果を読み込み，１文をChunkオブジェクトのリストとして表現し，冒頭の説明文の文節の文字列と係り先を表示せよ．本章の残りの問題では，ここで作ったプログラムを活用せよ．

MeCabの基本として，次のフォーマットにしたがって，記録される。
表層形\t品詞,品詞細分類1,品詞細分類2,品詞細分類3,活用型,活用形,原形,読み,発音
        [0],　　[1]　  ,　　[2]　  ,　　[3]　 ,[4]　 ,[5]　,[6] ,[7] ,[8]
"""

class Morph:
    """
        形態素を示すクラス
    """
    def __init__(self, line):
        self.surface, other = line.split("\t")
        other = other.split(",")
        
        self.base = other[6]
        self.pos = other[0]
        self.pos1 = other[1]
        
# 課題41
class Chunk:
    """
        文節を表すクラス
    """
    def __init__(self, morphs, dst, chunk_id):
        self.morphs = morphs    # Morphリスト
        self.dst = dst          # 係り先文節インデックス番号
        self.srcs = []          # 係り元文節インデックス番号のリスト
        self.chunk_id = chunk_id

class Sentence:
    """
        文章を表すクラス
    """
    def __init__(self, chunks):
        self.chunks = chunks    # Chunkリスト
        
        for i, chunk in enumerate(self.chunks):
            if chunk.dst not in [None, -1]: # Noneや-1を除く
                self.chunks[chunk.dst].srcs.append(i)   # 係り元リストにインデックスを追加
 

 
# 初期化
sentences = []  # ※前問とはリスト名を変えた
morphs = []
chunks = []
chunk_id = 0

# メインルーチン
with open("./assignments_folder/Chapter5/ai.ja.txt.parsed", encoding="utf-8") as f:
    for line in f:
        if line[0] == "*":  # *の場合スキップする
            if morphs:
                chunks.append(Chunk(morphs, dst, chunk_id))
                chunk_id += 1
                morphs = []
            dst = int(line.split()[2].replace("D", ""))
        elif line != "EOS\n":   # 文末でない場合Morphのインスタンスを生成
            morphs.append(Morph(line))
        else:  # 文末の場合
            chunks.append(Chunk(morphs, dst, chunk_id))
            sentences.append(Sentence(chunks))
            
            morphs = []
            chunks = []
            dst = None
            chunk_id = 0
        
# 出力
for chunk in sentences[2].chunks:   # 最初の2行は飛ばして，3行目の文章を表示
    chunk_str = "".join([morph.surface for morph in chunk.morphs])  # 文節中の形態素を繋げてstr化
    print(f"(文節の文字列, 係り先の文節番号)：({chunk_str}, {chunk.dst})")

"""
(文節の文字列, 係り先の文節番号)：(人工知能, 17)
(文節の文字列, 係り先の文節番号)：(（じんこうちのう、、, 17)
(文節の文字列, 係り先の文節番号)：(AI, 3)
(文節の文字列, 係り先の文節番号)：(〈エーアイ〉）とは、, 17)
(文節の文字列, 係り先の文節番号)：(「『計算, 5)
(文節の文字列, 係り先の文節番号)：(（）』という, 9)
(文節の文字列, 係り先の文節番号)：(概念と, 9)
(文節の文字列, 係り先の文節番号)：(『コンピュータ, 8)
(文節の文字列, 係り先の文節番号)：(（）』という, 9)
(文節の文字列, 係り先の文節番号)：(道具を, 10)
(文節の文字列, 係り先の文節番号)：(用いて, 12)
(文節の文字列, 係り先の文節番号)：(『知能』を, 12)
(文節の文字列, 係り先の文節番号)：(研究する, 13)
(文節の文字列, 係り先の文節番号)：(計算機科学, 14)
(文節の文字列, 係り先の文節番号)：(（）の, 15)
(文節の文字列, 係り先の文節番号)：(一分野」を, 16)
(文節の文字列, 係り先の文節番号)：(指す, 17)
(文節の文字列, 係り先の文節番号)：(語。, 34)
(文節の文字列, 係り先の文節番号)：(「言語の, 20)
(文節の文字列, 係り先の文節番号)：(理解や, 20)
(文節の文字列, 係り先の文節番号)：(推論、, 21)
(文節の文字列, 係り先の文節番号)：(問題解決などの, 22)
(文節の文字列, 係り先の文節番号)：(知的行動を, 24)
(文節の文字列, 係り先の文節番号)：(人間に, 24)
(文節の文字列, 係り先の文節番号)：(代わって, 26)
(文節の文字列, 係り先の文節番号)：(コンピューターに, 26)
(文節の文字列, 係り先の文節番号)：(行わせる, 27)
(文節の文字列, 係り先の文節番号)：(技術」、または、, 34)
(文節の文字列, 係り先の文節番号)：(「計算機, 29)
(文節の文字列, 係り先の文節番号)：(（コンピュータ）による, 31)
(文節の文字列, 係り先の文節番号)：(知的な, 31)
(文節の文字列, 係り先の文節番号)：(情報処理システムの, 33)
(文節の文字列, 係り先の文節番号)：(設計や, 33)
(文節の文字列, 係り先の文節番号)：(実現に関する, 34)
(文節の文字列, 係り先の文節番号)：(研究分野」とも, 35)
(文節の文字列, 係り先の文節番号)：(される。, -1)
"""

"""
―リーダブルコードの内容で実践したこと―
・p.171～p.173の「短いコードを書くこと」で，
リスト内包表記を使って、コンパクトで読みやすいコードを実現しています。
イギリスに関する記事を取得する際、filterとlambdaを使って処理を行っています。これにより、1行で必要なデータを抽出できます。

・p.10の「2.1 明確な単語を選ぶ」で，
変数名やコメントに明確な単語を使っています。例えば、"folderpath"や"filename"は、そのまま読んで意味が理解できる名前です。
"UK_article"という変数名は、イギリスに関する記事を表すため、そのままの名前を使用しています。

適切な変数名とコメント: 変数名やコメントが明確であり、コードの理解を助けています。例えば、textやsentenceといった変数名は適切であり、コメントも関数の役割を説明しています。
可読性のためのコードの分割: プログラム全体が1つの長い関数ではなく、論理的なブロックに分割されています。これにより、各部分の機能を理解しやすくなります。
条件分岐の明確化: 条件分岐が必要な箇所で条件式が明確になっており、可読性が向上しています。例えば、if len(line) == 2といった条件はシンプルで理解しやすいです。
適切なデータ構造の使用: 形態素解析結果を格納するために辞書やリストといった適切なデータ構造が使用されています。これにより、データの扱いや操作が容易になります。
適切な関数の使用: ファイルの読み込みやデータの解析に適切な関数が使用されており、コードが効率的であり、可読性が高まっています。
一貫性のあるスタイル: インデントやスペースの使用が一貫しており、コードのスタイルが統一されています。

"""